---
title: CAMPAIGN CLASSIC - [!UICONTROL Query incremental] coleta todos os registros em vez de somente os novos
description: Descrição
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS
resolution: Resolution
internal-notes: Ticket = TK197178
bug: true
article-created-by: Marta Zator
article-created-date: 5/10/2022 9:47:14 AM
article-published-by: Marta Zator
article-published-date: 5/10/2022 9:51:21 AM
version-number: 2
article-number: KA-15190
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad8bd527-46d0-ec11-a7b5-00224809c101
exl-id: f3dee0a7-8047-4949-9162-de95ba07fa7f
source-git-commit: dc1937169029c76dbce1ba513dd6430dffbc86c5
workflow-type: tm+mt
source-wordcount: '516'
ht-degree: 0%

---

# CAMPAIGN CLASSIC - [!UICONTROL Query incremental] coleta todos os registros em vez de somente os novos

## Descrição

O cliente tem várias queries incrementais que não estão funcionando como esperado. Em vez de coletar apenas novos registros desde a última execução, eles estão coletando todos os registros todas as vezes, como um registro normal [!UICONTROL Query] atividade.

## Resolução

O culpado é o [!UICONTROL Cleanup] fluxo de trabalho.

A variável [!UICONTROL Query incremental] o fluxo de trabalho funciona dessa maneira:

1. Mantenha uma tabela de histórico com resultados de iterações anteriores.
1. Buscar TODAS as linhas da consulta de destino.
1. Filtrar todas as linhas presentes na tabela de histórico
1. Adicione os resultados restantes à tabela de histórico para a próxima filtragem de iteração.

Portanto, esse nome de tabela de trabalho de histórico é da seguinte notação:

*wkfhistoworkflowid* activityName_

Agora, para workflowIDs 0 (para clientes em que a variável `xtknewid` permite sequências negativas), vemos que na verdade é:

*wkfhisto(uint)workflowid* activityName_

Embora isso seja adequado para a execução do workflow.

Assim, por exemplo, a atividade incremental `incremental1` do fluxo de trabalho ID=-1 criará uma tabela `wkfhisto4294967295_incremental1`.

A coisa que se perde é o [!UICONTROL Cleanup] fluxo de trabalho.

Temos um código que tenta excluir worktables de workflows excluídos.

Um código dedicado aqui lista todas as tabelas wkfhisto\*, extrai o workflowId de seus nomes (da convenção acima) e exclui todas, exceto aquelas cujas worklowIDs são encontradas na tabela xtkworkflow.

No entanto, `uint` parte.

Assim, ele tenta pesquisar um workflow com a ID 4294967295 em vez de convertê-lo de volta em int. Como esse workflow não foi encontrado, essa tabela é excluída. Na próxima vez, quando este workflow for executado, a variável [!UICONTROL Query incremental] A atividade do não encontra uma tabela de histórico existente e a cria pensando nisso como a primeira execução de sempre.

<b>Correção:</b>

A correção para esse problema está disponível na versão 20.1.1 do Adobe Campaign Classic (build 9122 e em diante).

<b>Soluções alternativas que os clientes podem usar:</b>

Solução alternativa 1: interrompa o fluxo de trabalho de limpeza e execute-o intermitentemente para limpar o banco de dados e o disco rígido até que a correção seja feita e esteja disponível. Não recomendado se você não tiver uma atualização planejada.

Solução alternativa 2: suponha que a variável [!UICONTROL Query incremental] a atividade é afetada e contorna-a fazendo a mesma coisa que a variável [!UICONTROL Query incremental] O faz criando um esquema persistente para manter o conteúdo da tabela de histórico. Use uma combinação de [!UICONTROL Query] e [!UICONTROL Atualizar dados] atividades para imitar o comportamento. Isso precisará ser feito para todos os workflows que exigem o query incremental.

Solução alternativa 3: suponha que a variável [!UICONTROL Query incremental] A atividade é afetada e contorna-a adicionando um campo de auditoria (tsCreated/tsLastModified) ao esquema em questão. Seu query incremental será convertido em uma atividade normal de query com uma cláusula where como `tscreated GetDate()`.

Solução alternativa 4:

- Crie uma nova sequência xtknewworkflowid e inicialize-a para algo que esteja longe dos intervalos atuais de workflowId.
- Altere o schema xtkworkflow para usar isso `pkSequence`
- Peça ao cliente para clonar todos os workflows afetados e excluir os originais.
- Quando o cliente estiver pronto para uma atualização, remova esta correção revertendo para `xtknewId` para a criação do workflow (para evitar surpresas indesejadas).
