---
title: "Query incremental coleta todos os registros em vez de apenas os novos"
description: Descrição
solution: Campaign
product: Campaign
applies-to: "Campaign Classic"
keywords: "KCS"
resolution: Resolution
internal-notes: "Ticket = TK197178"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "9/26/2022 10:11:48 AM"
article-published-by: Tanay Sharma .
article-published-date: "9/26/2022 11:03:23 AM"
version-number: 3
article-number: KA-15190
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e647789f-833d-ed11-9db1-002248086735"
source-git-commit: c07227262cb059b09254e8e1ec01542d4de2a881
workflow-type: tm+mt
source-wordcount: '353'
ht-degree: 0%

---

# A Consulta Incremental seleciona todos os registros em vez de somente os novos

## Descrição

<b>Ambiente</b>
Campaign Classic


<b>Problema/Sintomas</b>
As consultas incrementais não estão funcionando como esperado. Em vez de apenas coletar novos registros desde a última execução, eles estão coletando todos os registros cada vez como uma atividade de consulta normal.


## Resolução


Esse problema é corrigido na versão 20.1.1 do Adobe Campaign Classic (build 9122 e posteriores).

<b>Soluções alternativas que os clientes podem usar:</b>

<b>Solução 1</b>: Pare o workflow de limpeza e execute-o intermitentemente para limpar o banco de dados e o HDD até que a correção seja feita e disponibilizada. Não é recomendado se você não tiver uma atualização planejada.

<b>Solução 2</b>: Suponha que a atividade de query incremental seja afetada. Solucione isso fazendo a mesma coisa que o query incremental faz criando um schema persistente para manter o conteúdo da tabela do histórico. Use uma combinação de atividades de query e atualização de dados para simular o comportamento. Isso precisará ser feito para todos os workflows que exigem o query incremental.

<b>Solução 3</b>:  Suponha que a atividade de query incremental seja afetada. Alternar adicionando um campo de auditoria `tsCreated/tsLastModified` ao schema em questão. Seu query incremental será então convertido em uma atividade de query normal com uma cláusula where como &quot;GetDate() tscreated&quot;.

<b>Solução 4</b>:

1. Criar uma nova sequência `xtknewworkflowid` e inicialize-o para algo distante dos intervalos workflowId atuais.
2. Altere o `xtkworkflow` para usar este `pkSequence`.
3. Solicite ao cliente que clone todos os workflows afetados e exclua os originais.
4. Quando o cliente estiver pronto para uma atualização, remova essa correção revertendo para `xtknewId` para a criação do workflow (para evitar surpresas indesejadas).

<b>Causa</b>
O culpado é o fluxo de trabalho de limpeza.

O workflow de query incremental funciona dessa forma:

1. Mantém uma tabela de histórico com resultados de iterações anteriores.
2. Obtém todas as linhas da consulta de destino.
3. Filtra todas as linhas presentes na tabela de histórico
4. Adiciona os resultados restantes à tabela de histórico para a próxima filtragem de iteração.


Portanto, esse nome da tabela de trabalho do histórico é da seguinte notação:
`wkfhistoworkflowid` `activityName_`

Agora, para workflowIDs 0 (para clientes em que a variável `xtknewid` permite sequências negativas), vemos que é na verdade:

`wkfhisto(uint)workflowid``activityName_`

`Although this is okay for workflow execution.`

`So, for example, the incremental activity incremental1 of workflow ID=-1 will create a table wkfhisto4294967295_incremental1`.&quot;

`The thing which is missed is the CleanUp workflow.`

`Here, we have a code that tries to delete worktables of deleted workflows.`

`A dedicated code here lists all the wkfhisto tables, extracts the workflowId from their names (from the above convention), and deletes them all except the ones whose worklowIDs are found in the xtkworkflow table.`

`However, it misses the uint part.`

`So, it tries to look up a workflow with ID 4294967295 instead of casting this back to int. Since this workflow is not found, this table is deleted. Next time, when this workflow runs, the incremental query activity does not find an existing history table and creates it thinking of this as the first run ever.`
