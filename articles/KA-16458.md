---
title: "Análise de despejo AEM thread"
description: Descrição
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html"
bug: false
article-created-by: Emily Geary
article-created-date: "3/17/2021 9:11:03 PM"
article-published-by: Emily Geary
article-published-date: "3/17/2021 9:13:37 PM"
version-number: 2
article-number: KA-16458
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e70a8345-6587-eb11-a812-000d3a593216"
exl-id: 74bb70e4-a09b-48fc-8378-96a1736e5ebf
source-git-commit: a59847e2e7e37f432cb01150b9444cd9dbf585df
workflow-type: tm+mt
source-wordcount: '1000'
ht-degree: 0%

---

# Análise de despejo do thread de AEM

## Descrição

Analisar AEM [!DNL Java] despejos de thread usando [IBM Thread Analyzer](http://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=2245aa39-fa5c-4475-b891-14c205f7333c) ferramenta.

## Resolução

1. Baixe e instale [IBM Thread Analyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=2245aa39-fa5c-4475-b891-14c205f7333c) (vamos chamá-lo de IBM TDA para encurtar)
1. Captura [despejos de encadeamento](https://helpx.adobe.com/experience-manager/kb/TakeThreadDump.html) de uma instância AEM com problemas de desempenho.
1. Abra os dumps de encadeamento no IBM TDA.
1. Para exibir os detalhes de um despejo de thread, selecione o arquivo na listagem e clique no botão &quot;Detalhes do thread&quot;\*.

![tda-threaddetail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1587732783/tda-threaddetail.png "tda-threaddetail")

1. Classifique por &quot;Profundidade da pilha&quot; com as pilhas mais longas no topo.

   ![tda-image1](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image/tda-image1.png)

1. Revise os encadeamentos com profundidade de pilha de 10 linhas ou mais.  Esses são geralmente os encadeamentos de maior interesse.  Faça observações sobre encadeamentos de interesse.
1. Classificar por &quot;Estado&quot; do thread
1. Role para baixo até os threads &quot;Executáveis&quot;. Os threads executáveis são aqueles que estavam ocupando ativamente o tempo da CPU quando o despejo do thread foi obtido.

   *Observação: Ao revisar os threads &quot;Executáveis&quot;, você pode ignorar os threads listados na [Threads que podem ser ignorados](https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html#ignorethreads) na parte inferior desta página.*

1. Encontre encadeamentos executáveis que fazem parte do aplicativo, por exemplo, encadeamentos de tarefas em segundo plano ou encadeamentos de solicitações (os encadeamentos de solicitações têm nomes como este *127.0.0.1 1347028187737 GET /content/sites/global/en/sitemap.static-delivery.httpd.html HTTP/1.1*). Depois de encontrá-los, clique neles um por um.

1. Para cada thread de solicitação, você pode descobrir quando o navegador do usuário fez a solicitação ao servidor observando o carimbo de data e hora no nome do thread.  Por exemplo, no nome do thread acima, o carimbo de data e hora (em milissegundos no formato de época unix) é 1347028187737.  Podemos converter esse número de época em uma data/hora usando [www.epochconverter.com](http://www.epochconverter.com/).  Cada despejo de thread mostra a data e a hora em que foi tirado.  Você pode fazer a diferença no tempo entre o tempo de solicitação e o tempo de despejo de thread para ver por quanto tempo uma solicitação ficou ativa.

1. Depois de revisar os threads de solicitação, role pelos outros threads &quot;Executáveis&quot;.  Depois de encontrar um thread de interesse &quot;Executável&quot;, olhe o painel do meio, &quot;Threads em espera&quot;.  Os threads listados lá estão esperando o thread selecionado soltar um monitor.  Se você não vir nenhum thread em espera, seu thread selecionado ainda poderá ser o proprietário de um [Bloquear](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) (consulte as classes de implementação de [Bloquear](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) para obter detalhes). Por exemplo, com um [ReentrantReadWriteLock](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html) não é possível saber qual thread é o proprietário do bloqueio, pois os bloqueios implementam vários monitores internamente.  Portanto, talvez seja necessário examinar o código-fonte para combiná-lo com um thread que possa ser o proprietário do bloqueio.

1. Se o thread tiver um bloqueio ou monitor em que muitos outros threads estavam aguardando, passe pelo restante dos despejos para ver se é possível encontrar outros threads que tenham o mesmo problema.  Veja se o mesmo thread ainda existe nos outros despejos (no IBM TDA, você pode selecionar vários despejos de thread e clicar no botão &quot;Comparar threads&quot;\* para exibir o estado de um thread em vários despejos.

   ![tda-comparethreads](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1159496390/tda-comparethreads.png)

1. Consulte o Collector Service na captura de tela abaixo:

   ![tda-Image2](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1730877898/tda-Image2.png)

1. Nesta exibição, você pode ver o thread em vários despejos para ver se é um thread de execução longa.  Basicamente, se o thread estiver no estado Executável em vários despejos e tiver uma pilha longa, isso geralmente significa que é um thread de execução longa.

1. Se você não encontrou muita coisa procurando os threads executáveis, volte à lista de threads, selecione um dump de thread e clique no botão &quot;Detalhes do Monitor&quot;\* no painel superior. O IBM TDA abrirá uma janela mostrando uma visualização em árvore do monitor que possui threads e seus threads em espera. Observação: Ele pode exibir alguns threads de pool de threads como o monitor de pool de threads do mecanismo de servlet; os threads ociosos podem ser ignorados.  Você geralmente pode dizer que um thread é um thread de pool de thread ocioso porque na maioria das vezes ele tem apenas 10 linhas de pilha ou menos.

![tda-monitordetail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1106466084/tda-monitordetail.png)

<b>Utilização da CPU no nível do thread ([!DNL Linux] somente plataforma):</b>

1. Se você capturou a saída &quot;top -H -b -n1 -p javapid&quot; além dos dumps de encadeamento, é possível fazer referência cruzada à utilização da CPU no nível do encadeamento.  Abra a saída superior e obtenha o ID do processo dos threads que estão utilizando a CPU.  Converta o ID do processo em hexadecimal e procure esse valor hexadecimal no arquivo de despejo de thread correspondente.  O ID deve corresponder ao &quot;nid&quot; de um dos threads.
1. Se o thread correspondente que utiliza a maior parte da CPU for o &quot;VM Thread&quot; ou qualquer thread &quot;GC&quot;, você poderá ter um problema de memória.  Repita o mesmo exercício para mais despejos de encadeamento e saída superior e se houver um padrão desses encadeamentos levando tempo da CPU, você terá um problema de memória.
1. Se você confirmar o problema de memória, capture um despejo de heap na próxima vez que o problema ocorrer.  Consulte [este artigo](https://helpx.adobe.com/experience-manager/kb/AnalyzeMemoryProblems.html) para obter mais detalhes sobre como capturar e analisar despejos de heap.

![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)

Threads que podem ser ignorados:

- Thread de VM: Este é um thread do sistema VM.
- Threads que começam com o thread de tarefa do GC: Esses são threads de coleta de lixo.
- Threads com nomes semelhantes a - 1347028691218 no código em java.net.PlainSocketImpl.socketAccept(Método Nativo): Esses são threads do pool de threads do mecanismo de servlet aguardando novas conexões.
