---
title: "Análise de despejo AEM thread"
description: Descrição
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS, Práticas recomendadas, análise de despejo de thread AEM, Adobe Experience Manager, Java, IBM Thread Analyzer"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html"
bug: false
article-created-by: Jim Menn
article-created-date: "10/25/2022 2:34:41 AM"
article-published-by: Jim Menn
article-published-date: "10/25/2022 2:39:55 PM"
version-number: 3
article-number: KA-16458
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=6fb11892-0d54-ed11-bba2-6045bd006b4b"
source-git-commit: c75c557dd90af3ac51e113e0a9c61cf1c3de9618
workflow-type: tm+mt
source-wordcount: '1018'
ht-degree: 1%

---

# Análise de despejo do thread de AEM

## Descrição


<b>Ambiente</b>
Adobe Experience Manager

<b>Problema</b>
Analise AEM despejos de threads Java usando [IBM Thread Analyzer](https://www.ibm.com/support/pages/ibm-thread-and-monitor-dump-analyzer-java-tmda) ferramenta e práticas recomendadas.


## Resolução


<b>Solução</b>

<u><b>Siga estas etapas e práticas recomendadas para Analisar AEM despejos de threads Java usando <a data-ol-has-click-handler="" href="https://www.ibm.com/support/pages/ibm-thread-and-monitor-dump-analyzer-java-tmda">IBM Thread Analyzer</a> ferramenta</b></u><b>:</b>

1. Baixe e instale [IBM Thread Analyzer](https://www.ibm.com/support/pages/ibm-thread-and-monitor-dump-analyzer-java-tmda) (vamos chamá-lo de IBM TDA para encurtar).
2. Captura [despejos de encadeamento](https://helpx.adobe.com/experience-manager/kb/thread-dumps-collection-analysis.html) de uma instância AEM com problemas de desempenho.
3. Abra os dumps de encadeamento no IBM TDA.
4. Para exibir os detalhes de um despejo de thread, selecione o arquivo na listagem e clique no botão <b>Detalhes do thread</b> botão.

   ![tda-threaddetail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1587732783/tda-threaddetail.png "tda-threaddetail")
5. Classificar por <b>Profundidade da pilha</b> com as pilhas mais longas no topo.

   ![tda-image1](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image/tda-image1.png)
6. Revise os encadeamentos com profundidade de pilha de 10 linhas ou mais.  Esses são geralmente os encadeamentos de maior interesse.

   Faça observações sobre encadeamentos de interesse.
7. Classificar por thread <b>Estado</b>.
8. Role para baixo até a <b>Executável</b> threads. Os threads executáveis são aqueles que estavam ocupando ativamente o tempo da CPU quando o despejo do thread foi obtido.

   *Observação: Ao revisar a <b>Executável</b> threads, você pode ignorar os threads listados no [Threads que podem ser ignorados](https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html#ignorethreads) na parte inferior desta página.*


9. Encontre encadeamentos executáveis que fazem parte do aplicativo, por exemplo, encadeamentos de tarefas em segundo plano ou encadeamentos de solicitações (os encadeamentos de solicitações têm nomes como este *127.0.0.1 1347028187737 GET /content/sites/global/en/sitemap.static-delivery.httpd.html HTTP/1.1*).

   Depois de encontrá-los, clique neles um por um.
10. Para cada thread de solicitação, você pode descobrir quando o navegador do usuário fez a solicitação ao servidor observando o carimbo de data e hora no nome do thread.

   Por exemplo, no nome do thread acima, o carimbo de data e hora (em milissegundos no formato de época unix) é *1347028187737*.

   Podemos converter esse número de época em uma data/hora usando [www.epochconverter.com](http://www.epochconverter.com/).

   Cada despejo de thread mostra a data e a hora em que foi tirado.

   Você pode fazer a diferença no tempo entre o tempo de solicitação e o tempo de despejo de thread para ver por quanto tempo uma solicitação ficou ativa.
11. Depois de revisar os encadeamentos da solicitação, role pelo outro <b>Executável</b> threads.

   Depois de encontrar um thread de interesse Executável, olhe para o painel do meio, <b>Aguardando threads</b>.

   Os threads listados lá estão esperando o thread selecionado soltar um monitor.

   Se você não vir nenhum thread em espera, seu thread selecionado ainda poderá ser o proprietário de um [Bloquear](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) (consulte as classes de implementação de [Bloquear](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) para obter detalhes).

   Por exemplo, com um [ReentrantReadWriteLock](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html) não é possível saber qual thread é o proprietário do bloqueio, pois os bloqueios implementam vários monitores internamente.

   Portanto, talvez seja necessário examinar o código-fonte para combiná-lo com um thread que possa ser o proprietário do bloqueio.
12. Se o thread tiver um bloqueio ou monitor em que muitos outros threads estavam aguardando, passe pelo restante dos despejos para ver se é possível encontrar outros threads que tenham o mesmo problema.

   Veja se o mesmo thread ainda existe nos outros despejos (no IBM TDA, você pode selecionar vários despejos de thread e clicar no botão <b>Comparar threads</b> para exibir o estado de um thread em vários despejos de thread.

   ![tda-comparethreads](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1159496390/tda-comparethreads.png)
13. Consulte a <b>Serviço de Coletor</b> na captura de tela abaixo:

   ![tda-Image2](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1730877898/tda-Image2.png)
14. Nesta exibição, você pode ver o thread em vários despejos para ver se é um thread de execução longa.

   Basicamente, se o thread estiver no <b>Executável</b> em vários despejos e tiver uma pilha longa, isso geralmente significa que é um thread de execução longa.
15. Se você não encontrou muita coisa olhando para o <b>Executável</b> threads, retorne à listagem de threads, selecione um despejo de thread e clique em <b>Detalhes do monitor</b> no painel superior.

   O IBM TDA abrirá uma janela mostrando uma visualização em árvore do monitor que possui threads e seus threads em espera.

   Observação: Ele pode exibir alguns threads de pool de threads, como o monitor de pool de threads do mecanismo de servlet, os threads ociosos podem ser ignorados.

   Você geralmente pode dizer que um thread é um thread de pool de thread ocioso porque na maioria das vezes ele tem apenas 10 linhas de pilha ou menos.

   ![tda-monitordetail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1106466084/tda-monitordetail.png)




<u><b>Utilização da CPU no nível do thread (somente na plataforma Linux)</b></u><b>:</b>

1. Se você tiver capturado `top -H -b -n1 -p javapid` além dos despejos de thread, você pode fazer referência cruzada da utilização da CPU no nível do thread.

   Abra a saída superior e obtenha o ID do processo dos threads que estão utilizando a CPU.

   Converta o ID do processo em hexadecimal e procure esse valor hexadecimal no arquivo de despejo de thread correspondente.

   O ID deve corresponder ao <b>nid</b> de um dos threads.
2. Se o thread correspondente que utiliza a maior parte da CPU for o <b>Thread de VM</b> ou <b>GC</b> threads então você pode ter um problema de memória.

   Repita o mesmo exercício para mais despejos de encadeamento e saída superior. Se houver um padrão desses encadeamentos levando tempo da CPU, você terá um problema de memória.
3. Se você confirmar o problema de memória, capture um despejo de heap na próxima vez que o problema ocorrer.

   Veja isso [Artigo Analisar problemas de memória](https://experienceleague.adobe.com/docs/experience-cloud-kcs/kbarticles/KA-17482.html?lang=pt-BR) para obter mais detalhes sobre como capturar e analisar despejos de heap.


![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)

<b><u>Threads que podem ser ignorados</u>:</b>

- Thread de VM: Este é um thread do sistema VM.
- Threads que começam com o thread de tarefa do GC: Esses são threads de coleta de lixo.
- Threads com nomes semelhantes a `- 1347028691218 in code at java.net.PlainSocketImpl.socketAccept(Native Method)`: Esses são threads do pool de threads do mecanismo de servlet aguardando novas conexões.

