---
title: "Otimizar consulta SQL gerada no assistente de atualização de banco de dados"
description: "Saiba como resolver o problema do Adobe Campaign Classic em que novas colunas precisam ser adicionadas a um esquema existente."
solution: Campaign,Campaign Classic v7
product: Campaign,Campaign Classic v7
applies-to: "Campaign Classic,Campaign,Campaign Classic v7"
keywords: "KCS, Campaign Classic V7, otimizar consulta SQL gerada, assistente de atualização de banco de dados"
resolution: Resolution
internal-notes: "It can be helpful when dealing with database update issues with big tables"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "5/3/2024 12:44:18 PM"
article-published-by: Tanay Sharma .
article-published-date: "5/3/2024 12:49:40 PM"
version-number: 4
article-number: KA-15785
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=d6a7c3d4-4a09-ef11-9f8a-6045bd026dc7"
source-git-commit: 82cdb0cae5d8318fe8de839aff1ab26694f46437
workflow-type: tm+mt
source-wordcount: '357'
ht-degree: 0%

---

# Otimizar consulta SQL gerada no assistente de atualização de banco de dados

## Descrição {#description}


<b>Ambiente</b>
Adobe Campaign Adobe Campaign Classic

<b>Problema</b>
Na maioria das builds do Adobe Campaign, incluindo as do Gold Standard 9032, você pode encontrar vários problemas ao adicionar novas colunas a um esquema existente.

O escopo deste artigo é abordar um problema específico relacionado a:

- Adição de um campo inteiro a um esquema existente quando os registros já existem.
- Otimize a query SQL gerada pelo aplicativo para uma eficiente para SQL Postgres.


<b>Causa</b>
<br>Isso pode acontecer quando você, por exemplo, tem uma tabela de recipient existente ou qualquer outra tabela que já tem mais de 1 milhão de registros.
<br>Se, agora, você precisar adicionar uma coluna extra a essa tabela, que é do tipo de dados `Integer`.
<br>Em seguida, você adiciona essa coluna na definição do esquema e deseja confirmar as alterações no banco de dados.

<br>Ao atualizar o banco de dados, o banco de dados encontra um deadlock ou o query bloqueia outras operações.
<br>Isso se deve principalmente à atualização de todos os registros para *0* com base no comando SQL gerado pelo assistente de banco de dados.<br>

## Resolução {#resolution}


<b>Solução</b>
Ao adicionar uma coluna inteira, você obtém a instrução SQL gerada semelhante a esta:


```
ALTER TABLE NmsRecipient ADD <column_name> SMALLINT;
UPDATE NmsRecipient SET <column_name> = 0;
ALTER TABLE NmsRecipient ALTER COLUMN <column_name> SET Default 0;
ALTER TABLE NmsRecipient ALTER COLUMN i<column_name> SET NOT NULL;
```


O problema aqui é que há 4 comandos executados em paralelo no banco de dados que podem causar problemas de desempenho ou um deadlock.

A solução é condensar esses 4 comandos em um e ainda fazer as mesmas alterações conforme abaixo:


```
ALTER TABLE NmsRecipient ADD iFichierLiveDataCliqueurs SMALLINT NOT NULL SET Default 0 ;
```


Ele faz todas as alterações necessárias, adicionando a coluna, definindo o padrão, definir `NOT NULL`e também definindo o valor dos registros existentes como *0* devido à `NOT NULL` restrição.



<b>NOTA:</b>

Se houver várias colunas inteiras que precisam ser adicionadas, adicione-as uma por uma e execute o assistente de banco de dados para cada alteração.

Isso é para garantir uma operação suave, pois a instrução atualiza todas <b>existente </b>registros para *0* além disso, e dependendo do número de registros, pode levar tempo.
