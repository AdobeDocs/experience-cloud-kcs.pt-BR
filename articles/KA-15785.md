---
title: Otimizar consulta SQL gerada no assistente de atualização de banco de dados
description: Descrição
solution: Campaign,Campaign Classic v7
product: Campaign,Campaign Classic v7
applies-to: Campaign Classic,Campaign,Campaign Classic v7
keywords: KCS, Campaign Classic V7, otimizar consulta SQL gerada, assistente de atualização de banco de dados
resolution: Resolution
internal-notes: It can be helpful when dealing with database update issues with big tables
bug: true
article-created-by: Jim Menn
article-created-date: 9/30/2022 2:28:44 PM
article-published-by: Jim Menn
article-published-date: 9/30/2022 4:49:05 PM
version-number: 3
article-number: KA-15785
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=f9d8b92d-cc40-ed11-9db1-0022480866ad
exl-id: 73e8701c-88e5-4b73-8c55-90eaee26d2ac
source-git-commit: 4702b69f883128bf305ec64f012ef01903f3f582
workflow-type: tm+mt
source-wordcount: '338'
ht-degree: 0%

---

# Otimizar consulta SQL gerada no assistente de atualização de banco de dados

## Descrição


<b>Ambiente</b>
Adobe Campaign Adobe Campaign Classic

<b>Problema</b>
Na maioria das builds do Adobe Campaign, incluindo as do Gold Standard 9032, você pode encontrar vários problemas ao adicionar novas colunas a um esquema existente.

O escopo deste artigo é abordar um problema específico relacionado a:

- Adição de um campo inteiro a um esquema existente quando os registros já existem.
- Otimize a query SQL gerada pelo aplicativo para uma eficiente para SQL Postgres.


<b>Causa</b>
<br>Isso pode acontecer quando você, por exemplo, tem uma tabela de recipient existente ou qualquer outra tabela que já tem mais de 1 milhão de registros.
<br>Se, agora, você precisar adicionar uma coluna extra a essa tabela, que é do tipo de dados `Integer`.
<br>Em seguida, você adiciona essa coluna na definição do esquema e deseja confirmar as alterações no banco de dados.

<br>Ao atualizar o banco de dados, o banco de dados encontra um deadlock ou o query bloqueia outras operações.
<br>Isso se deve principalmente à atualização de todos os registros para *0* com base no comando SQL gerado pelo assistente de banco de dados.<br>

## Resolução


<b>Solução</b>
Ao adicionar uma coluna inteira, você obtém a instrução SQL gerada semelhante a esta:


```
ALTER TABLE NmsRecipient ADD column_name SMALLINT;
UPDATE NmsRecipient SET column_name = 0;
ALTER TABLE NmsRecipient ALTER COLUMN column_name SET Default 0;
ALTER TABLE NmsRecipient ALTER COLUMN icolumn_name SET NOT NULL;
```


O problema aqui é que há 4 comandos executados em paralelo no banco de dados que podem causar problemas de desempenho ou um deadlock.

A solução é condensar esses 4 comandos em um e ainda fazer as mesmas alterações conforme abaixo:


```
ALTER TABLE NmsRecipient ADD iFichierLiveDataCliqueurs SMALLINT NOT NULL SET Default 0 ;
```


Ele faz todas as alterações necessárias, adicionando a coluna, definindo o padrão, definir `NOT NULL`e também definindo o valor dos registros existentes como *0* devido à `NOT NULL` restrição.



<b>NOTA:</b>

Se houver várias colunas inteiras que precisam ser adicionadas, adicione-as uma por uma e execute o assistente de banco de dados para cada alteração.

Isso é para garantir uma operação suave, pois a instrução atualiza todas <b>existente </b>registros para *0* além disso, e dependendo do número de registros, pode levar tempo.
