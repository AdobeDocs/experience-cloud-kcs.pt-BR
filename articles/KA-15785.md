---
title: Campaign Classic V7 - Otimizar consulta SQL gerada no assistente de atualização do banco de dados
description: Descrição
solution: Campaign,Campaign Classic v7
product: Campaign,Campaign Classic v7
applies-to: Campaign Classic,Campaign,Campaign Classic v7
keywords: KCS
resolution: Resolution
internal-notes: It can be helpful when dealing with database update issues with big tables
bug: true
article-created-by: Marta Zator
article-created-date: 5/5/2022 10:16:35 AM
article-published-by: Marta Zator
article-published-date: 5/5/2022 10:18:58 AM
version-number: 2
article-number: KA-15785
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e810bb6a-5ccc-ec11-a7b5-6045bd00dbbc
exl-id: 73e8701c-88e5-4b73-8c55-90eaee26d2ac
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '318'
ht-degree: 1%

---

# Campaign Classic V7 - Otimizar consulta SQL gerada no assistente de atualização do banco de dados

## Descrição


<b>Contexto e contexto :</b>
Na maioria das [!DNL Campaign] construções incluindo [!DNL Gold Standard] 9032, podem ocorrer vários problemas ao adicionar novas colunas a um schema existente.

O escopo deste artigo é abordar um problema específico relacionado a :

- Adição de um campo inteiro a um schema existente quando os registros já existem.
- Otimize o query SQL gerada pelo aplicativo para uma consulta eficiente para Postgres SQL.


<b>Caso de uso :</b> 
<br>Temos uma tabela de recipients existente ou qualquer outra tabela que já tenha mais de 1 milhão de registros.
<br>Agora precisamos adicionar uma coluna extra a essa tabela, que é do tipo de dados inteiro.
<br>Adicionamos essa coluna na definição do schema e queremos confirmar as alterações no banco de dados.

<b>Desafio </b>:
<br>Encontramos e emissão ao atualizar o banco de dados e o banco de dados encontra um impasse ou o query bloqueia outras operações.
<br>Isso se deve principalmente à atualização de todos os registros para 0 com base no comando SQL gerado pelo assistente de banco de dados.


<br> <br>

## Resolução


Solução :

Ao adicionar uma coluna inteira , obtemos a instrução SQL gerada desta forma :

```
ALTER TABLE NmsRecipient ADD column_name SMALLINT;
UPDATE NmsRecipient SET column_name = 0;
ALTER TABLE NmsRecipient ALTER COLUMN column_name SET Default 0;
ALTER TABLE NmsRecipient ALTER COLUMN icolumn_name SET NOT NULL;
```

O problema aqui é que há quatro comandos executados em paralelo no banco de dados que podem causar problemas de desempenho ou um bloqueio.

A solução é condensar esses 4 comandos em um e ainda fazer as mesmas alterações que abaixo:

```
ALTER TABLE NmsRecipient ADD iFichierLiveDataCliqueurs SMALLINT NOT NULL SET Default 0 ;
```

Ele faz todas as alterações necessárias, adicionando a coluna, definindo o padrão e definindo `NOT NULL`e também definir o valor dos registros existentes como 0 por causa do `NOT NULL` restrição.



<b>OBSERVAÇÃO :</b>

Se houver várias colunas inteiras que precisam ser adicionadas, adicione-as uma por uma e execute o assistente de banco de dados para cada alteração.

Isso garante uma operação suave, pois a instrução atualiza todos os <b>existente </b>também registra como 0 e dependendo do no. de registros pode levar tempo.
